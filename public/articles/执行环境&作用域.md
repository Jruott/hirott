#执行环境&作用域
###一.执行环境（exection context,也称之为执行上下文）
执行环境是一个概念，一种机制，用来完成javascript运行时在作用域，生存期等方面的处理，它定义了变量或者函数是否有权访问其他数据。所有javascript代码都是在一个执行环境中被执行的

**Javascript中的函数“在定义它们的作用域里运行，而不是在执行它们的作用域里运行”**，这是权威指南里抽象而精辟的总结。

js只有全局作用域和函数作用域

当调用一个javascript函数时,会创建一个执行环境，该函数就会进入与该函数相对于的执行环境。如果又调用另外一个函数（或递归的调用同一个函数），则又会创建一个新的执行环境，并且在函数调用期间执行过程都处于该环境中。当调用的函数返回后，执行过程会返回原始执行环境。

因此，运行中的javascript代码就构成了一个执行环境栈。
	
	var color = "blue";
	function Fn1(){
		var anothercolor = "red";
		function Fn2(){
			var tempcolor = anothercolor;
			anothercolor = color;
		}
		Fn2();
	}
	Fn1()

![](/upload/执行环境.png)

程序在进入每个执行环境的时候，JavaScript引擎在内部创建一个对象，叫做变量对象（Variable Object）。对应函数的每一个参数，在Variable Object上添加一个属性，属性的名字、值与参数的名字、值相同。函数中每声明一个变量，也会在Variable Object上添加一个属性，名字就是变量名，因此为变量赋值就是给Variable Object对应的属性赋值。(即当JavaScript引擎调用一些函数时,该函数会创建一个新的活动对象,所有在函数内部定义的局部变量以及传入函数的命名参数和arguments对象都会作为这个活动对象的属性.这个活动对象加上该函数的[[scope]]内部属性中存储的作用域链就组成了本次函数调用的作用域链.)

#二.作用域/作用域链（Scope/Scope Chain）
当代码在一个环境中执行时，都会创建基于Variable Object的一个作用域链。 作用域链的用途是保证对执行环境有权访问的所有变量和函数的有序访问。整个作用域链是由不同执行位置上的Variable Object按照规则所构建一个链表。作用域链的最前端，始终是当前正在执行的代码所在环境的Variable Object。如果这个环境是函数（比如Fn2），则将其活动对象（activation object)作为变量对象。活动对象在最开始时只包含一个变量，就是函数内部的arguments对象。作用域链中的下一个Variable Object来自该函数(Fn2)的包含环境（也就是Fn1)，而再下一个Variable object来自再下一个包含环境。这样，一直延续到全局执行环境，全局执行环境的Variable Object始终是作用域链中的最后一个对象。

![](/upload/作用域链.png)

如上所述，作用域链感觉就是一个Variable Object链表，当访问一个变量时，先在链表的第一个Variable Object（最前端）上查找，如果没有找到则继续在第二个Variable Object上查找，直到搜索结束，也就是搜索到全局执行环境的Variable Object中。这也就形成了Scope Chain的概念。

---

#总结：  

1.内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间是线性、有次序的。当前调用函数处于作用域的前端

2.Javascript中的函数“在定义它们的作用域里运行，而不是在执行它们的作用域里运行”

3.调用对象位于作用域链的前端，局部变量（在函数内部用var声明的变量）、函数参数及Arguments对象都在函数内的作用域中——这意味着它们隐藏了作用域链更上层的任何同名的属性。

4.函数的词法作用域和作用域链是不同的东西，词法作用域是抽象概念，作用域链是实例化的调用对象链。

5.函数在被定义的时候，同时也是它外层的函数在被执行的时候。

6.函数在被定义的时候它的词法作用域就已经确定了，但它仍然是抽象的概念，没有也不能被实例化。

7.函数在被定义的时候还确定了一个东西，就是它外层函数的作用域链，这个是实例化的东西。

8.函数在被多次调用的时候，它的作用域链都是不同的。


#小例子

1.而在javascript中则不是这样的，在for中的变量声明将会添加到当前的执行环境中（这里是全局执行环境），因此在for循环完后，变量i依旧存在于循环外部的执行环境。因此，会输出10。

	for(var i=0;i<10;i++){
		   doSomething(i);
	}
	alert(i); // output :10,why?


2.

	var tt = 'aa';
	function test(){
	    alert(tt);    //undefined
	    var tt = 'dd';
	    alert(tt);    //dd
	}
	test(); 
调用对象位于作用域链的前端，局部变量（在函数内部用var声明的变量）、函数参数及Arguments对象都在函数内的作用域中——这意味着它们隐藏了作用域链更上层的任何同名的属性。

即，在以上程序片段中，test函数内部的“var tt='dd'”将会致使“var tt='aa'”在test函数被调用时完全被隐藏。而且，tt是在第一个alert语句之后定义，所以在调用到第一个alert时，tt是还没有被赋值的。这样说可能会清楚一点，即，在定义test函数时，当定义第一个alert(tt)时，这里会记录tt是作用域链中的一个变量但不会记录它（tt）的值，函数定义完毕后tt就添加到作用域里，所以第一个alert语句能够找到该作用域里的tt（即，相当于找到一个已经在函数内部声明，但未被赋值的tt）。